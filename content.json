{"pages":[],"posts":[{"title":"Docker容器使用","text":"Docker客户端容器使用获取镜像获取镜像，如果我们本地没有镜像，先pull拉取一个Ubuntu镜像 docker pull ubuntu 启动镜像使用ubuntu镜像启动容器 $ docker run -it ubuntu /bin/bash docker run ：创建一个新的容器并运行一个命令 退出终端输入exit 语法： 1docker run [OPTIONS] IMAGE [COMMAND] [ARG...] OPTIONS 选项说明： -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项； -d: 后台运行容器，并返回容器ID； -i: 以交互模式运行容器，通常与 -t 同时使用； -P: 随机端口映射，容器内部端口随机映射到主机的高端口 -p: 指定端口映射，格式为：主机(宿主)端口:容器端口 -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； –name=”nginx-lb”: 为容器指定一个名称； –dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致； –dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致； -h “mars”: 指定容器的hostname； -e username=”ritchie”: 设置环境变量； –env-file=[]: 从指定文件读入环境变量； –cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行； -m :设置容器使用内存最大值； –net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型； –link=[]: 添加链接到另一个容器； –expose=[]: 开放一个端口或一组端口； –volume , -v: 绑定一个卷 查看所有的容器执行命令: docker ps -a 执行结果： [root@baseserver docker]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2663af2afb45 ubuntu &quot;/bin/bash&quot; 4 minutes ago Exited (0) 2 minutes ago infallible_leavitt启动以停止的容器 docker start [容器id] 停止启动的容器 docker stop [容器id] 重启容器 docker restart [容器id] 后台运行执行命令： $ docker run -itd --name ubuntu-test ubuntu 执行选项增加-d，启动后返回容器id。 进入容器进入容器有两种方式，执行docker attach或 docker exec命令。 1、使用docker attach命令进入容器 使用docker attach命令，如果从这个容器退出，会导致容器的停止。 2、使用docker exec命令进入容器 使用exec命令，如果从容器退出，不会导致容器停止。 语法：docker exec [OPTIONS] CONTAINER COMMAND [ARG...] 导入导出容器导出容器导出容器使用docker export 命令 $ docker export 2663af2afb45 &gt; ubuntu_bak.tar 导入容器导入容器使用docker import命令 语法: docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]] OPTIONS说明： -c :应用docker 指令创建镜像； -m :提交时的说明文字； 删除容器使用docker rm -f 删除容器 语法： docker rm [OPTIONS] CONTAINER [CONTAINER...] OPTIONS说明： -f :通过 SIGKILL 信号强制删除一个运行中的容器。 -l :移除容器间的网络连接，而非容器本身。 -v :删除与容器关联的卷。 执行命令删除容器：docker rm -f 2663af2afb45 删除所有已经停止的容器: docker rm $(docker ps -a -q)","link":"/2020/06/08/Docker%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/"},{"title":"Dubbo Can not lock the registry cache file 错误解决","text":"错误引发原因有多个线程在争夺一个文件的文件锁所引发的异常，而这个文件是dubbo的注册缓冲文件。 Dubbo在保存服务列表时失败，Can not lock the registry cache file /root/.dubbo/dubbo-registry-127.0.0.1.cache，拿不到文件锁，无法保存服务列表。 Dubbo通过注册中心发现服务，发现的服务Dubbo同时也会保存到本地缓存一份。 缓存的好处有很多，比如不需要每次使用的时候都通过注册中心获取，注册中心不可用了，不影响消费端的调用，因为本地缓存了一份服务提供者列表。 Dubbo本地缓存默认采用的文件，会根据注册中心自动在当前用户目录下生成一个缓存文件，类似/root/.dubbo/dubbo-registry-....cache。 星号表示注册中心的IP地址，当同一台机器上同时启动多个进程，就会出现多个进程争夺此文件的写入权限 java.io.IOException: Can not lock the registry cache file /root/.dubbo/dubbo-registry-127.0.0.1.cache, ignore and retry later, maybe multi java process use the file, please config: dubbo.registry.file=xxx.properties at com.alibaba.dubbo.registry.support.AbstractRegistry.doSaveProperties(AbstractRegistry.java:193) at com.alibaba.dubbo.registry.support.AbstractRegistry$SaveProperties.run(AbstractRegistry.java:150) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748)解决方法1、删除缓冲文件dubbo的注册缓冲文件默认地址为${user.home}.dubbo\\dubbo-registry-....cache，其中${user.home}是计算机的根目录。 在启动时日志也可以看到，目录为/root 2020-03-23 14:30:11.561 [main] INFO org.apache.zookeeper.ZooKeeper - Client environment:user.name=root 2020-03-23 14:30:11.561 [main] INFO org.apache.zookeeper.ZooKeeper - Client environment:user.home=/root执行命令： [root@ds ~]# cd /root/.dubbo/ [root@ds .dubbo]# ll total 904 -rw-r--r-- 1 root root 111768 May 31 2019 dubbo-registry-127.0.0.1.cache -rw-r--r-- 1 root root 0 May 7 2019 dubbo-registry-127.0.0.1.cache.lock [root@ds .dubbo]# rm -rf *Windows环境同理 移动到 C:\\Users\\用户名\\.dubbo 文件夹 全选删除全部文件夹2、为每个服务配置独立的缓冲文件通过配置dubbo配置文件来解决。 配置dubbo registry的file属性，来指定缓冲文件生成的地址及文件名。 属性描述：使用文件缓存注册中心地址列表及服务提供者列表，应用重启时将基于此文件恢复，注意：两个注册中心不能使用同一文件存储 dubbo-registry配置文档 属性 对应URL参数 类型 是否必填 缺省值(默认值) 作用 兼容性 file registry.file string 可选 ${user.home}.dubbo\\dubbo-registry-....cache 服务治理 2.0.0以上版本 &lt;dubbo:registry id=&quot;register&quot; address=&quot;${dubbo.registry.address}&quot; file=&quot;/var/cache/${dubbo.application.name}.cache&quot;/&gt;","link":"/2020/03/23/Dubbo%20Can%20not%20lock%20the%20registry%20cache%20file%20%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"},{"title":"Docker部署SpringBoot程序包","text":"Docker部署SpringBoot程序包1、准备好要部署的服务包执行 mvn clean package -DskipTests -U，将target目录下的jar包拷贝出来 2、编写Dockerfile文件123456FROM java:8 VOLUME /tmp ADD dubbodemo-api-web-0.0.1-SNAPSHOT.jar app.jarRUN bash -c 'touch /app.jar'ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]RUN /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; echo 'Asia/Shanghai' &gt;/etc/timezone FROM：:项目依赖，需要一个 java 8 版本的 jdkADD：第一个参数为 JAR 包的名称， 第二个人参数自定义名称，打包后的名称ENTRYPOINT：运行 JAR 包的指令， 如 java -jar app.jar 为 [“java”,”-jar”,”/app.jar”]注意这里的 app.jar 和 ADD 的第二个参数对应 3、构建Dockerfile1、将jar包及Dockerfile上传至同一目录 2、执行docker build -t demoapi:v0.0.1 .构建docker 镜像 1234567891011121314151617181920212223242526272829303132333435[root@baseserver springbootDemoTest]# docker build -t demoapi:v0.0.1 . Sending build context to Docker daemon 65.66MBStep 1/6 : FROM java:88: Pulling from library/java5040bd298390: Pull complete fce5728aad85: Pull complete 76610ec20bf5: Pull complete 60170fec2151: Pull complete e98f73de8f0d: Pull complete 11f7af24ed9c: Pull complete 49e2d6393f32: Pull complete bb9cdec9c7f3: Pull complete Digest: sha256:c1ff613e8ba25833d2e1940da0940c3824f03f802c449f3d1815a66b7f8c0e9dStatus: Downloaded newer image for java:8 ---&gt; d23bdf5b1b1bStep 2/6 : VOLUME /tmp ---&gt; Running in e2e27a328035Removing intermediate container e2e27a328035 ---&gt; 8156be7ed8e9Step 3/6 : ADD dubbodemo-api-web-0.0.1-SNAPSHOT.jar app.jar ---&gt; ec941d760399Step 4/6 : RUN bash -c 'touch /app.jar' ---&gt; Running in ad15976c44b4Removing intermediate container ad15976c44b4 ---&gt; c5a8ee93d057Step 5/6 : ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] ---&gt; Running in e39a95508d95Removing intermediate container e39a95508d95 ---&gt; 36c421cb2a14Step 6/6 : RUN /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; echo 'Asia/Shanghai' &gt;/etc/timezone ---&gt; Running in 38364c2b1a7aRemoving intermediate container 38364c2b1a7a ---&gt; ce01f8172bfbSuccessfully built ce01f8172bfbSuccessfully tagged demoapi:v0.0.1 看到Successfully说明build成功 4、运行dokcer image123456[root@baseserver springbootDemoTest]# docker run -itd -p 18105:18105 --name demoapi demoapi:v0.0.1 561ac0acb78149c43304dbe6c279975e6a6019d3a5ccf85e03eb77f68d645bc6[root@baseserver springbootDemoTest]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES561ac0acb781 demoapi:v0.0.1 &quot;java -Djava.securit…&quot; 48 seconds ago Up 47 seconds 0.0.0.0:18105-&gt;18105/tcp demoapi curl 访问测试 12[root@baseserver springbootDemoTest]# curl 127.0.0.1:18105/test{&quot;errorCode&quot;:200,&quot;errorMessage&quot;:&quot;requestSuccess&quot;,&quot;data&quot;:null}[root@baseserver springbootDemoTest]#","link":"/2020/06/30/Docker%E9%83%A8%E7%BD%B2SpringBoot%E7%A8%8B%E5%BA%8F%E5%8C%85/"},{"title":"Linux Nginx安装及配置","text":"1、Nginx简介Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。 2、Nginx应用场景2.1、Http服务器Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。 2.2、虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。 2.3、反向代理、负载均衡当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。 3、正向代理与反向代理3.1、正向代理所谓正向代理其实就和我们平时所做的翻墙一样，例如:当我们想要访问某些国外的**网站时，因为某些原因我们无法访问到，这时候我们就可以找代理，代理有能力访问到那个网站，而我们只需要访问代理。就可以得到那个网站的内容了。且代理可以决定是否将用户信息告诉给网站。总的来说正向代理是一个位于客户端与原始服务器之间的一个代理服务器，为了从原始服务器获取内容，客户端向代理发送一个请求并指定目标服务器(原始服务器),然后代理服务器向原始服务器转交请求并获取内容交给目标服务器，客户端必须进行特殊的设置才能使用正向代理。 3.2、反向代理与正向代理相反，举个例子：当用户访问某个服务器下的内容时，其实该服务器并无此内容，但是该服务器通过反向代理从另一台服务器中获取到了用户想要的内容，并返回给了用户。用户以为是在此服务器下获取到的内容，其实并不是。 总的来说，反向代理用户不需要进行特殊的设置，对用户来说他以为访问得到的内从是从原始服务器中得到的。其实是客户端向反向代理的命名空间中发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容 原本就是它自己的一样。 4、安装nginx4.1、下载下载nginx，推荐使用Stable version版本 4.2、安装环境4.2.1 安装依赖1.gcc编译依赖gcc环境，如果没有gcc环境，需要安装gcc 2.PCREPCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。 3.zliblib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。 4.opensslOpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。 执行命令: yum install -y gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel 4.2.2 编译安装解压： 12tar -zxvf nginx-1.16.1.tar.gzcd nginx-1.16.1 创建临时目录： 1mkdir -p /var/temp/nginx 执行下列命令： 12345678910111213141516./configure \\--prefix=/usr/local/nginx \\--pid-path=/var/run/nginx/nginx.pid \\--lock-path=/var/lock/nginx.lock \\--error-log-path=/var/log/nginx/error.log \\--http-log-path=/var/log/nginx/access.log \\--with-http_gzip_static_module \\--http-client-body-temp-path=/var/temp/nginx/client \\--http-proxy-temp-path=/var/temp/nginx/proxy \\--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\--with-http_stub_status_module \\--with-http_ssl_module \\--with-stream \\--with-stream_ssl_module \\--http-scgi-temp-path=/var/temp/nginx/scgi 开始编译和安装 12makemake install 安装成功查看安装目录 123456789101112[root@server1 ~]# cd /usr/local/nginx/[root@server1 nginx]# lltotal 36drwx------ 2 nobody root 4096 Feb 4 11:16 client_body_tempdrwxr-xr-x 2 root root 4096 Feb 4 11:16 confdrwx------ 2 nobody root 4096 Feb 4 11:16 fastcgi_tempdrwxr-xr-x 2 root root 4096 Feb 4 11:16 htmldrwxr-xr-x 2 root root 4096 Feb 4 11:16 logsdrwx------ 2 nobody root 4096 Feb 4 11:16 proxy_tempdrwxr-xr-x 2 root root 4096 Feb 4 11:16 sbindrwx------ 2 nobody root 4096 Feb 4 11:16 scgi_tempdrwx------ 2 nobody root 4096 Feb 4 11:16 uwsgi_temp 4.3启动nginx12cd /usr/local/nginx/sbin/./nginx 启动完成后验证： 1234[root@server1 nginx]# ps -aux | grep nginxroot 5291 0.0 0.0 112712 960 pts/1 S+ 19:51 0:00 grep --color=auto nginxroot 6529 0.0 0.0 20548 604 ? Ss Feb04 0:00 nginx: master process ./nginxnobody 6530 0.0 0.0 20992 1564 ? S Feb04 0:00 nginx: worker process 启动pid 6529为nginx主线程，pid 6530位nginx工作线程 4.4 关闭nginx执行命令： ./nginx -s quit 4.5 重启nginx执行命令： ./nginx -s reload 4.6 Nginx测试浏览器访问： 安装nginx服务器ip，页面显示Welcome to nginx!即为安装成功。 5.搭建负载均衡5.1 什么是负载均衡负载均衡 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。负载均衡，英文名称为Load Balance，其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。 5.2 负载均衡的优点简单的来说。可以减少服务器的压力，将原本一台服务器所要承受的访问量分给了多台，并提高了项目的可用性，当一台服务器挂掉的时候也不会导致整个项目瘫痪。 5.3 nginx实现负载均衡nginx作为负载均衡服务器，用户请求先到达nginx，再由nginx根据负载配置将请求转发至 tomcat服务器。 nginx负载均衡服务器：192.168.1.10 tomcat1服务器：192.168.1.11 tomcat2服务器：192.168.1.12 当我们通过10负载访问项目接口时，nginx会自动将请求轮流分配给11与12来执行。 5.4 负载均衡配置12345678910111213141516171819cd /usr/local/nginx/conf/vim nginx.conf#在server上添加此upstream节点upstream upstream.test{ #weight 权重 即访问11与12的次数比例为1比1 server 192.168.1.11:18180 weight=1; server 192.168.1.12:18180 weight=1;}server { listen 80; server_name localhost; #location的/匹配所有请求 location / { #使用upstream.test分配规则，即刚自定义添加的upstream节点 proxy_pass http://upstream.test; }} 配置完成，保存并退出。","link":"/2020/02/23/Linux%E4%B8%8B%E7%9A%84Nginx%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/"},{"title":"MySQL date,datetime,timestamp的区别","text":"MySQL有三种日期类型 date datetime timestamp 定义date: 日期 如：2020-03-01 不带时分秒。 datetime: 日期时间 如：2020-03-01 17:20:00 带时分秒。 timestamp: 时间戳， 时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。 时间范围date: ‘1000-01-01’ to ‘9999-12-31’ datetime: ‘1000-01-01 00:00:00’ to ‘9999-12-31 23:59:59’ timestamp: ‘1970-01-01 00:00:01’ UTC to ‘2038-01-19 03:14:07’ UTC 常用方法查看当前时间戳两种方法 mysql&gt; select unix_timestamp(); +------------------+ | unix_timestamp() | +------------------+ | 1583311205 | +------------------+ 1 row in set (0.00 sec) mysql&gt; select unix_timestamp(now()); +-----------------------+ | unix_timestamp(now()) | +-----------------------+ | 1583311215 | +-----------------------+ 1 row in set (0.00 sec)查看当前时间mysql&gt; select now(); +---------------------+ | now() | +---------------------+ | 2020-03-04 16:41:43 | +---------------------+ 1 row in set (0.00 sec)时间转时间戳mysql&gt; select unix_timestamp(&apos;2020-01-01 00:00:00&apos;); +---------------------------------------+ | unix_timestamp(&apos;2020-01-01 00:00:00&apos;) | +---------------------------------------+ | 1577808000 | +---------------------------------------+ 1 row in set (0.00 sec)时间戳转时间mysql&gt; select from_unixtime(1577808000); +---------------------------+ | from_unixtime(1577808000) | +---------------------------+ | 2020-01-01 00:00:00 | +---------------------------+ 1 row in set (0.00 sec)时间戳格式化mysql&gt; SELECT from_unixtime(1577808000, &apos;%Y年%m月%d日 %H:%i:%S&apos;); +----------------------------------------------------+ | from_unixtime(1577808000, &apos;%Y年%m月%d日 %H:%i:%S&apos;) | +----------------------------------------------------+ | 2020年01月01日 00:00:00 | +----------------------------------------------------+ 1 row in set (0.00 sec)时间格式化mysql&gt; select date_format(now(), &apos;%Y年%m月%d日&apos;); +------------------------------------+ | date_format(now(), &apos;%Y年%m月%d日&apos;) | +------------------------------------+ | 2020年03月04日 | +------------------------------------+ 1 row in set (0.00 sec) mysql&gt; select date_format(&apos;2020-01-01 12:00:00&apos;, &apos;%Y年%m月%d日 %H时%i分%S秒&apos;); +-----------------------------------------------------------------+ | date_format(&apos;2020-01-01 12:00:00&apos;, &apos;%Y年%m月%d日 %H时%i分%S秒&apos;) | +-----------------------------------------------------------------+ | 2020年01月01日 12时00分00秒 | +-----------------------------------------------------------------+ 1 row in set (0.00 sec)","link":"/2020/03/04/MySQL%20date,datetime,timestamp%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"Linux 环境jdk配置","text":"1、查看Linux有无自带的jdk（openjdk）执行命令： 1234567[root@server1 ~]# rpm -qa | grep javajavapackages-tools-3.4.1-11.el7.noarchtzdata-java-2019c-1.el7.noarchjava-1.8.0-openjdk-devel-1.8.0.242.b08-0.el7_7.x86_64java-1.8.0-openjdk-headless-1.8.0.242.b08-0.el7_7.x86_64python-javapackages-3.4.1-11.el7.noarchjava-1.8.0-openjdk-1.8.0.242.b08-0.el7_7.x86_64 2、卸载自带的openjdk123rpm -e --nodeps java-1.8.0-openjdk-devel-1.8.0.242.b08-0.el7_7.x86_64rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.242.b08-0.el7_7.x86_64rpm -e --nodeps java-1.8.0-openjdk-1.8.0.242.b08-0.el7_7.x86_64 3、卸载完成后校验1234[root@server1 ~]# rpm -qa | grep javajavapackages-tools-3.4.1-11.el7.noarchtzdata-java-2019c-1.el7.noarchpython-javapackages-3.4.1-11.el7.noarch 4、安装jdk4.1、下载jdk包oracle jdk下载下载 jdk版本-linux-x64.tar.gz 4.2、解压 jdk-8u201-linux-x64.tar.gz 到指定目录下：执行命令：tar -zxvf jdk-8u231-linux-x64.tar.gz -C /usr/local/ 4.3、配置环境变量执行命令：vim /etc/profile向文件尾部添加： 1234export JAVA_HOME=/usr/local/jdk1.8.0_231export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin 4.4、source 执行profile文件执行命令：source /etc/profile 5、验证jdk安装1234[root@server1 local]# java -versionjava version \"1.8.0_231\"Java(TM) SE Runtime Environment (build 1.8.0_231-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.231-b11, mixed mode)","link":"/2020/02/23/Linux-JDK%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"title":"idea重写toString模版","text":"idea重写toString模版 1、alt+insert 呼出生成选择框 2、点击setting 设置 3、新增自定义模版 4、选择生成toString所使用的模版 JSON字符串模版12345678910111213141516171819202122public java.lang.String toString() {final java.lang.StringBuilder sb = new java.lang.StringBuilder(\"{\");#set ($i = 0)#foreach ($member in $members)#if ($i == 0)sb.append(\"######elsesb.append(\",#####end#if ($member.string || $member.date)\\\"$member.name\\\":\\\"\")#else\\\"$member.name\\\":\")#end#if ($member.primitiveArray || $member.objectArray).append(java.util.Arrays.toString($member.name));#elseif ($member.string || $member.date).append($member.accessor).append('\\\"');#else.append($member.accessor);#end#set ($i = $i + 1)#endsb.append('}');return sb.toString();}","link":"/2020/05/22/idea%E9%87%8D%E5%86%99toString%E6%A8%A1%E7%89%88/"},{"title":"Windows环境下安装RabbitMQ","text":"RabbitMQ是一个在AMQP协议标准基础上完整的，可复用的企业消息系统。它遵循Mozilla Public License开源协议，采用 Erlang 实现的工业级的消息队列(MQ)服务器，Rabbit MQ 是建立在Erlang OTP平台上。 1、安装Erlang安装Erlang需要注意RabbitMQ所依赖的版本。 rabbitmq官网上有关于erlang版本的对应关系说明：RabbitMQ and Erlang/OTP Compatibility Matrix Erlang下载地址 下载需要版本的Erlang Windows二进制文件 otp_win64_22.3.exe 安装完成后配置环境变量： 1、变量名： ERLANG_HOME 变量值： Erlang安装目录 2、编辑path变量 在结尾追加%ERLANG_HOME%\\bin 命令行测试： 123C:\\Users\\ccwf&gt;erlEshell V10.7 (abort with ^G)1&gt; 2、安装RabbitMQRabbitMQ下载地址 ，下载RabbitMQV3.8.3.exe 。安装mq的目录不允许有空格及中文。 3、安装RabbitMQ-Pluglins使用命令行，cd进入安装目录下的sbin目录，执行命令：rabbitmq-plugins enable rabbitmq_management 123456789101112131415D:\\DevelopSoft\\RabbitMQServer\\rabbitmq_server-3.8.3\\sbin&gt;rabbitmq-plugins enable rabbitmq_managementEnabling plugins on node rabbit@C-W-F:rabbitmq_managementThe following plugins have been configured: rabbitmq_management rabbitmq_management_agent rabbitmq_web_dispatchApplying plugin configuration to rabbit@C-W-F...The following plugins have been enabled: rabbitmq_management rabbitmq_management_agent rabbitmq_web_dispatchstarted 3 plugins. 登录管理后台：访问http://127.0.0.1:15672","link":"/2020/03/25/Windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85RabbitMq/"},{"title":"myBatis的jdbcType和javaType，mySQL的对应类型","text":"JdbcType简介数据库列字段都是有类型的，不同的数据库有不同的类型。为了表示这些数据类型，Java 源码是采用枚举来定义的 package java.sql; public enum JDBCType implements SQLType { INTEGER(Types.INTEGER), DOUBLE(Types.DOUBLE), VARCHAR(Types.VARCHAR), TIMESTAMP(Types.TIMESTAMP), ...... } 枚举变量也是有类型的，也是有值的，正如整数变量是整数类型，也有值大小一样，上述枚举变量值的定义是通过 Types 来描述刻画的。 public class Types { public final static int INTEGER = 4; public final static int DOUBLE = 8; public final static int VARCHAR = 12; public final static int TIMESTAMP = 93; ｝MyBatis包含的JdbcTypeBIT FLOAT CHAR TIMESTAMP OTHER UNDEFINED TINYINT REAL VARCHAR BINARY BLOB NVARCHAR SMALLINT DOUBLE LONGVARCHAR VARBINARY CLOB NCHAR INTEGER NUMERIC DATE LONGVARBINARY BOOLEAN NCLOB BIGINT DECIMAL TIME NULL CURSOR JdbcType JavaType MySqlType CHAR String CHAR VARCHAR String CHAR LONGVARCHAR String VARCHAR NUMERIC BigDecimal NUMERIC TINYINT byte TINYINT SMALLINT short SMALLINT INTEGER int INTEGER BIGINT long BIGINT REAL float REAL FLOAT double FLOAT DOUBLE double DOUBLE DATE java.sql.Date DATE TIMESTAMP java.sql.Timestamp TIMESTAMP/DATETIME TIMESTAMP java.util.Date TIMESTAMP/DATETIME CLOB Clob CLOB BLOB Blob BLOB","link":"/2020/03/04/myBatis%E7%9A%84jdbcType%E5%92%8CjavaType%EF%BC%8CmySQL%E7%9A%84%E5%AF%B9%E5%BA%94%E7%B1%BB%E5%9E%8B/"},{"title":"多线程与高并发学习一","text":"多线程与高并发学习笔记基本概念进程一个程序运行起来之后，叫做进程。对于程序来讲，是一个动态的概念。例如qq.exe,jvm。 线程作为一个进程，他最小的执行单元，叫做线程。粗略的讲就是一个程序里不同的执行路径。 在java中创建线程的两种方式 一、class 继承Thread方法，并重写run方法。 二、定义一个类实现Runnable接口，并重写run方法。 三、使用Lambda表达式 new Thread(()-&gt;{}) 注意，启动调用方法为Thread.start(); 线程最基本方法1、Thread.sleep当前线程暂停一段时间，让给别的线程执行。 2、Thread.yield让线程从执行状态离开，进入等待队列，也就是就绪状态。 3、Thread.join 将其他线程加入到当前线程中。join常用与等待另外一个线程的结束。 synchronizedsynchronized(Object) 实际上锁定的是Object对象，不是代码，谁持有Object对象的锁，谁就可以运行。 Object不能使用String常量，Integer，Long 会出现一些不可控的异常。 synchronized方法与非锁定方法可以同时执行 可重入锁synchronized是可重入锁，每一个锁关联一个线程持有者和计数器，当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法。当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为 1。此时其它线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为 0，则释放该锁。 锁升级无锁 &gt; 偏向锁 &gt; 自旋锁 &gt; 重量级锁 偏向锁在对象的markword上记录下当前的线程指针，同一个线程枷锁时候，不需要争用，只需要判断线程指针是否为同一个，所以偏向锁偏向枷锁的第一个线程。 轻量级锁当有线程争用同样资源时，锁升级为轻量锁。没个线程都有自己的LockRecord在自己的线程栈上。用cas去争用markword的LockRecord指针。指针指向哪个线程的LockRecord，哪个线程就拥有锁。当锁自选超过10次时，或者自旋线程数超过CPU核数的一半， 1.6之后，加入自适应自旋 Adapative Self Spinning ， JVM自己控制，锁升级为重量级锁。如果太多线程自旋，会消耗大量CPU性能，升级为重量级锁进入等待队列反而节省cpu资源。 重量级锁向操作系统申请资源，线程挂起，进入等待队列，等待操作系统的调度。 synchronized与CAS该用哪个？在高争用 高耗时的环境下synchronized效率更高在低争用 低耗时的环境下CAS效率更高synchronized到重量级之后是等待队列（不消耗CPU）CAS（等待期间消耗CPU） synchronized锁优化锁细化：将锁力度变细，当争用不是很剧烈的前提下，锁的粒度越小越好。采用细粒度的锁，可以使线程争用时间变短，从而提高效率。 锁粗化：当某一个方法或某一段业务逻辑锁细化太细，争用太频繁时，更换为一个大锁，争用就没有那么频繁。 synchronizd使用规范1、当使用对象作为锁时，要保证对象不变。对被锁定的对象增加final属性。 2、不要使用String常量作为锁。 volatilevolatile作用：保证线程之间的可见性，禁止指令重排序。 如何保证线程之间的可见性在CPU级别使用缓存一致性协议保证的。 volatile类型的变量每次值被修改了就立即同步回主内存，每次使用时就需要从主内存重新读取值。而普通变量没有要求这一点，所以普通变量修改值是不会被其他线程立即可见的。简单案例： 1234567891011121314151617181920212223public class L { public volatile Boolean flag = true; public void m(){ System.out.println(&quot;m start&quot;); while (flag){ } System.out.println(&quot;m end&quot;); } public static void main(String[] args) { L l = new L(); new Thread(l::m).start(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } l.flag = false; }} volatile只能保证线程的可见性，不能保证原子性。 禁止指令重排序在虚拟机级别，增加volatile关键字，语言级别禁止。JVM内存屏障，使用读屏障（loadfence原语指令），写屏障（storefence 原语指令），由CPU提供支持。 CAS(无锁优化 自旋)在java.util.concurrent.atomic包内，以Atomic开头原子类，都是使用cas来保证线程安全。 常用场景：多线程访问一个值，这个值需要往上递增，计数器。jdk提供了一些类，例如AtomicInteger。 cas： compare and set比较并且设定，如何实现线程安全：每次写入时，查看值是否被别人改过，是否为期望值。当读取到的值为期望值时写入，如果不为期望值，说明在执行过程中，有别的线程访问并修改此值。这时会再次读取重试一遍或者失败。 ABA问题最简单的解决方案 增加version版本号 A 1.0B 2.0A 3.0","link":"/2020/07/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E4%B8%80/"},{"title":"多线程与高并发学习二","text":"多线程与高并发学习笔记可重入锁ReentrantLock使用方法：12345678910Lock lock = new ReentrantLock(); void method1{ try { lock.lock(); //执行方法前获得锁 }finally { //执行方法后手动释放锁 lock.unlock(); } } 手动上锁，使用完成后手动释放锁。 尝试获取锁 try lock尝试获取锁，当超过设置的等待时间，不再尝试获取锁。 1234567891011121314151617public void method2(){ boolean lockFlag = false; try { lockFlag = lock.tryLock(10,TimeUnit.SECONDS); if(lockFlag) { System.out.println(&quot;m2&quot;); }else { System.out.println(&quot;m2 can not get Lock&quot;); } } catch (InterruptedException e) { e.printStackTrace(); }finally { if (lockFlag){ lock.unlock(); } } } 公平锁与非公平锁公平锁：谁等待的时间最长谁先执行。非公平锁：cpu运行随机抽取，空闲时轮到哪个线程就那个显存执行。 如果使用公平锁：默认不传入fair时，锁为非公平锁。 1234567891011121314151617181920212223242526272829public static void main(String[] args) { ReentrantLock lock = new ReentrantLock(true); Runnable runnable = new Runnable() { @Override public void run() { for (int i = 0; i &lt; 5; i++) { lock.lock(); try { System.out.println(Thread.currentThread().getName() + &quot;获取锁&quot;); Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } } }; Thread t1 = new Thread(runnable,&quot;t1&quot;); Thread t2 = new Thread(runnable,&quot;t2&quot;); Thread t3 = new Thread(runnable,&quot;t3&quot;); Thread t4 = new Thread(runnable,&quot;t4&quot;); Thread t5 = new Thread(runnable,&quot;t5&quot;); t1.start(); t2.start(); t3.start(); t4.start(); t5.start(); } 当为公平锁时，输出结果一致，谁等待时间长执行谁。 12345678910t1获取锁t2获取锁t4获取锁t3获取锁t5获取锁t1获取锁t2获取锁t4获取锁t3获取锁t5获取锁 当为非公平锁时，随机执行 123456789101112131415t1获取锁t1获取锁t1获取锁t1获取锁t1获取锁t3获取锁t3获取锁t3获取锁t3获取锁t3获取锁t2获取锁t2获取锁t2获取锁t2获取锁t2获取锁 响应中断下面代码定义了一个锁lock，当t1死锁时，t2一直在尝试获取锁，造成堵塞。调用线程2的interrupt打断运行。 1234567891011121314151617181920212223242526272829303132333435363738394041public static void main(String[] args) { ReentrantLock lock = new ReentrantLock(); Thread t1 = new Thread(()-&gt;{ lock.lock(); System.out.println(&quot;t1 start&quot;); try { TimeUnit.DAYS.sleep(2); System.out.println(&quot;t1 end&quot;); } catch (InterruptedException e) { e.printStackTrace(); }finally { lock.unlock(); } },&quot;t1&quot;); t1.start(); Thread t2 = new Thread(()-&gt;{ boolean lockFlag = false; try { //尝试获取锁 //lockInterruptibly对线程interrupt做出响应。 lock.lockInterruptibly(); lockFlag = lock.isLocked(); System.out.println(&quot;t2 start&quot;); } catch (InterruptedException e) { System.err.println(&quot;t2 wait broken&quot;);// e.printStackTrace(); }finally { if (lockFlag){ lock.unlock(); } } },&quot;t2&quot;); t2.start(); try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); } //打断T2 t2.interrupt(); } ReentrantLock对比SynchronizedReentrantLock可以替代Synchronized,可以完成ReentrantLock可以替代Synchronized的人和功能,使用CAS获取锁。 有一些Synchronized没有的功能： trylock 尝试获取锁,可以设置等待时间。 lockInterruptibly 可以中断等待. 可以设置公平锁与非公平锁，synchronized只有非公平锁。 ReentrantLock与Synchronized都为独占锁（悲观锁）。 读写锁允许多个线程同时访问读取资源，写入时只允许一个线程访问资源。在写入时，所有的读取与写入线程会被阻塞。读写锁实际维护了一对锁，分别是读锁与写锁。 适用于大量读取操作，写入不多的场景。在并发读取时候大大提高效率。 读锁：共享锁 写锁：排他锁(独占锁) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182private static int i = 1; public static void main(String[] args) { ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); ReentrantLock reentrantLock = new ReentrantLock(); Lock readLock = readWriteLock.readLock(); Lock writeLock = readWriteLock.writeLock(); long start = System.currentTimeMillis(); CountDownLatch countDownLatch = new CountDownLatch(15); for (int j = 0; j &lt; 10; j++) { new Thread(() -&gt; { read(reentrantLock); countDownLatch.countDown(); }).start(); } for (int j = 0; j &lt; 5; j++) { int finalJ = j; new Thread(() -&gt; { write(reentrantLock, finalJ); countDownLatch.countDown(); }).start(); } try { countDownLatch.await(); } catch (InterruptedException e) { e.printStackTrace(); } long end = System.currentTimeMillis(); System.out.println(&quot;reentrantLock耗时：&quot; + (end - start) / 1000 + &quot;秒&quot;); long start1 = System.currentTimeMillis(); CountDownLatch countDownLatch2 = new CountDownLatch(15); for (int j = 0; j &lt; 10; j++) { new Thread(() -&gt; { read(readLock); countDownLatch2.countDown(); }).start(); } for (int j = 0; j &lt; 5; j++) { int finalJ = j; new Thread(() -&gt; { write(writeLock, finalJ); countDownLatch2.countDown(); }).start(); } try { countDownLatch2.await(); } catch (InterruptedException e) { e.printStackTrace(); } long end1 = System.currentTimeMillis(); System.out.println(&quot;读写锁耗时：&quot; + (end1 - start1) / 1000 + &quot;秒&quot;); } public static int read(Lock lock) { int temp = 0; lock.lock(); try { TimeUnit.SECONDS.sleep(1); temp = i; System.out.println(&quot;read：&quot; + i); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } return temp; } public static void write(Lock lock, int val) { lock.lock(); try { TimeUnit.SECONDS.sleep(1); System.out.println(&quot;write：&quot; + val); i = val; } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } 12reentrantLock耗时：15秒readWriteLock耗时：6秒","link":"/2020/07/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E4%BA%8C/"},{"title":"多线程与高并发学习三","text":"多线程与高并发学习笔记CountDownLatch倒数计数门栓，相比Thread.join 更灵活。 1234567891011121314151617181920public static void main(String[] args) { CountDownLatch latch = new CountDownLatch(50); for (int i = 0; i &lt; 50; i++) { new Thread(()-&gt;{ System.out.println(Thread.currentThread().getName()); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } latch.countDown(); }).start(); } try { latch.await(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()); } new CountDownLatch(50) 设置门栓的数量为50，latch.countDown()将门栓数量-1，countDown操作为原子操作，不会存在线程安全的问题。latch.await()等待门栓数量减为0后往下运行。 CyclicBarrier线程的计数器，CyclicBarrier构造器有两个参数，第一个参数为凑够多少的线程就执行的数值，第二个为每次执行后的run事件。 cyclicBarrier.await()，等待释放。 123456789101112131415public static void main(String[] args) { CyclicBarrier cyclicBarrier = new CyclicBarrier(10,()-&gt; System.out.println(&quot;cyclicBarrier释放执行&quot;)); for (int i = 0; i &lt; 100; i++) { new Thread(()-&gt;{ System.out.println(Thread.currentThread().getName()); try { cyclicBarrier.await(); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } }).start(); } } 执行结果： 123456789101112131415161718192021222324Thread-0Thread-4Thread-3Thread-2Thread-1Thread-7Thread-6Thread-5Thread-10Thread-9Thread-8Thread-13cyclicBarrier释放执行Thread-12Thread-11Thread-14Thread-15Thread-16Thread-17Thread-18Thread-19cyclicBarrier释放执行Thread-20... Semaphore信号量，指定可以同时有多少个线程运行，用于限流。默认为非公平。 semaphore.acquire()：如果acquire未获取到运行许可，则会阻塞。运行完成后在finally释放。 123456789101112131415161718192021222324252627282930313233343536373839public static void main(String[] args) { Semaphore semaphore = new Semaphore(2); new Thread(() -&gt; { try { semaphore.acquire(); System.out.println(&quot;t1 run&quot;); TimeUnit.SECONDS.sleep(1); System.out.println(&quot;t1 run&quot;); } catch (InterruptedException e) { e.printStackTrace(); } finally { semaphore.release(); } }).start(); new Thread(() -&gt; { try { semaphore.acquire(); System.out.println(&quot;t2 run&quot;); TimeUnit.SECONDS.sleep(1); System.out.println(&quot;t2 run&quot;); } catch (InterruptedException e) { e.printStackTrace(); } finally { semaphore.release(); } }).start(); new Thread(() -&gt; { try { semaphore.acquire(); System.out.println(&quot;t3 run&quot;); TimeUnit.SECONDS.sleep(1); System.out.println(&quot;t3 run&quot;); } catch (InterruptedException e) { e.printStackTrace(); } finally { semaphore.release(); } }).start();}","link":"/2020/07/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E4%B8%89/"},{"title":"设计模式-1.工厂模式","text":"工厂模式定义一个用于创建产品的接口，由子类决定生产什么产品。 1、工厂模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，创建对象不会对客户端暴露创建逻辑，并且通过共同的接口来创建新的对象。 2、应用实例： ​ 1、hibernate更换数据库只需要更换方言以及数据库驱动类 ​ 2、你需要一辆汽车，可以直接从工厂里提货，而不用管这辆汽车是怎么做出来的，以及这个汽车里面具体的实现。 3、优点： ​ 1、一个调用者想创建一个对象，只需要知道名字就可以。 ​ 2、扩展性高，如果想增加一个产品，只需要扩展一个工厂类就可以。 ​ 3、屏蔽产品的具体实现，调用者只关心产品的接口 4、缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。 5、作为一个创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过new就可以完成创建的对象，无需使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 code： 1、定义一个创建产品的接口 Sender，创建两个实现类SMSSender，EmailSender。一个工厂类SenderFactory。 Sender接口 123456789101112131415/** * @Description: 发送信息器 * @author:ccwf * @date:2020/6/19 9:23 */public interface Sender { /** * 发送消息 * @author ccwf * @date 2020/6/19 9:24 * @param msg * @return void */ public void sendMessage(String msg);} 短信发送器 12345public class SMSSender implements Sender { public void sendMessage(String msg) { System.out.println(\"短信发送内容:\" + msg); }} 邮件发送器 123456public class EmailSender implements Sender{ public void sendMessage(String msg) { System.out.println(\"邮件发送内容:\" + msg); }} 工厂类 123456789101112public class SenderFactory { public static Sender getSender(String senderType){ if (\"sms\".equals(senderType)){ return new SMSSender(); }else if (\"email\".equals(senderType)){ return new EmailSender(); }else { throw new RuntimeException(\"无匹配的实现类\"); } }} 测试类 123456789public class FactoryTest { public static void main(String[] args) { Sender smsSender = SenderFactory.getSender(\"sms\"); smsSender.sendMessage(\"短信\"); Sender emailSender = SenderFactory.getSender(\"email\"); emailSender.sendMessage(\"邮件\"); }} 输出结果 短信发送内容:短信 邮件发送内容:邮件","link":"/2020/06/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-2.抽象工厂模式","text":"抽象工厂模式相对于简单工厂模式来说，抽象工厂模式针对于多种对象多个工厂，但是原理都是工厂模式，操作类似。 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂的其他工厂。该超级工厂又称为其他工厂。这种类型的设计模式属于创建模型模式，它提供了一种创建对象的最佳方式； 在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显示指定它们的类，每个生成的工厂都能按照工厂模式提供对象。 意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 主要解决：主要解决接口选择的问题。 何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一个族的产品。 如何解决：在一个产品族里面，定义多个产品。 关键代码：在一个工厂里聚合多个同类产品。 code： 123public interface Shape { void draw();} 12345public class Circle implements Shape{ public void draw() { System.out.println(\"画了个圆\"); }} 12345public class Rectangle implements Shape{ public void draw() { System.out.println(\"画了一个长方形\"); }} 123public interface Color { void getColoerName();} 12345public class Blue implements Color{ public void getColoerName() { System.out.println(\"蓝\"); }} 12345public class Green implements Color{ public void getColoerName() { System.out.println(\"绿\"); }} 12345public class Red implements Color{ public void getColoerName() { System.out.println(\"红\"); }} 1234567891011121314151617public class ShapeFactory extends AbstractFactory{ @Override public Color getColor(String color) { return null; } @Override public Shape getShape(String shapeType) { if (shapeType.equalsIgnoreCase(\"CIRCLE\")) { return new Circle(); } else if (shapeType.equalsIgnoreCase(\"RECTANGLE\")) { return new Rectangle(); } else{ throw new RuntimeException(\"无匹配的实现类\"); } }} 1234567891011121314151617181920public class ColorFactory extends AbstractFactory{ @Override public Color getColor(String color){ if ((\"red\").equalsIgnoreCase(color)) { return new Red(); } else if ((\"green\").equalsIgnoreCase(color)) { return new Green(); } else if ((\"blue\").equalsIgnoreCase(color)) { return new Blue(); }else { throw new RuntimeException(\"无匹配的实现类\"); } } @Override public Shape getShape(String shape) { return null; }} 123456public abstract class AbstractFactory { public abstract Color getColor(String color); public abstract Shape getShape(String shape);} 12345678910public class FactoryProducer { public static AbstractFactory getFactory(String type) { if (\"shape\".equalsIgnoreCase(type)) { return new ShapeFactory(); } else if (\"color\".equalsIgnoreCase(type)) { return new ColorFactory(); } return null; }} 12345678910111213141516171819public class AbstractFactoryTest { public static void main(String[] args) { AbstractFactory shapeFactory = FactoryProducer.getFactory(\"SHAPE\"); Shape shape1 = shapeFactory.getShape(\"CIRCLE\"); shape1.draw(); Shape shape2 = shapeFactory.getShape(\"RECTANGLE\"); shape2.draw(); AbstractFactory colorFactory = FactoryProducer.getFactory(\"COLOR\"); Color color1 = colorFactory.getColor(\"RED\"); color1.getColoerName(); Color color2 = colorFactory.getColor(\"GREEN\"); color2.getColoerName(); Color color3 = colorFactory.getColor(\"BLUE\"); color3.getColoerName(); }}","link":"/2020/06/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-3.单例模式","text":"单例模式单例模式（Singleton Pattern）是Java最简单设计模式之一。这种类型的设计模式属于创建型模式，它提供一种常见对象的最佳方式。 这种模式涉及到一个单一类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象方式，可以直接访问，不需要实例化该类的对象。 优点： ​ 1、在JAM中，该对象只有一个实例，减少内存开销，省去了new操作符，降低了系统内存的使用频率，减轻GC压力。 ​ 2、避免对资源的多重占有，例如写文件这种操作。 缺点： ​ 1、没有接口，不能继承。一个类值关心 内部逻辑，不关心外部如何实例化。 使用场景： ​ 1、要求生成唯一序列号。 ​ 2、WEB中的计数器，不用每次刷新都在数据库加一次，用单例先缓存起来 ​ 3、创建一个对象需要消耗的资源过多，比如I/O于数据库的连接等； Code： 饿汉模式：类加载时就创建了对象，直接使用 123456789101112131415161718/** * 单例模式 * 饿汉 */public class SingleObject { private static final SingleObject singleObject = new SingleObject(); private SingleObject() { } public void showMsg() { System.out.println(\"SingleObject\"); } public static SingleObject getInstance() { return singleObject; }} 懒汉模式，线程不安全。在多线程中使用的时候，可能会创建多个实例对象。 123456789101112131415161718public class SingleObject1 { private static SingleObject1 singletObject1; private SingleObject1() { } public static SingleObject1 getInstance() { if (singletObject1 == null) { singletObject1 = new SingleObject1(); } return singletObject1; } public void showMsg() { System.out.println(\"SingleObject1\"); }} 对于多线程调用情况下，对获取对象的方法增加一个同步锁 ，可以在多线程中很好的工作。但是大部分情况下不需要同步，效率很低。 123456789101112131415161718public class SingleObject2 { private static SingleObject2 singletObject2; private SingleObject2() { } public static synchronized SingleObject2 getInstance() { if (singletObject2 == null) { singletObject2 = new SingleObject2(); } return singletObject2; } public void showMsg() { System.out.println(\"SingleObject2\"); }} 使用双重校验锁来保证线程安全，这种方式使用双锁机制，在多线程情况下也可以保证高性能。 1234567891011121314151617181920public class SingleObject3 { private static volatile SingleObject3 singleObject3; private SingleObject3() { } public static SingleObject3 getInstance(){ if (singleObject3 == null){ synchronized (SingleObject3.class){ if(singleObject3 == null){ singleObject3 = new SingleObject3(); } } } return singleObject3; } public void showMsg() { System.out.println(\"SingleObject3\"); }} 测试方法： 1234567891011121314151617181920public class SingleObjectTest { public static void main(String[] args) { SingleObject singleObject = SingleObject.getInstance(); singleObject.showMsg(); SingleObject1 singleObject1 = SingleObject1.getInstance(); singleObject1.showMsg(); SingleObject2 singleObject2 = SingleObject2.getInstance(); singleObject2.showMsg(); SingleObject3 singleObject3 = SingleObject3.getInstance(); singleObject3.showMsg(); System.out.println(singleObject.toString()); System.out.println(SingleObject.getInstance().toString()); System.out.println(singleObject1.toString()); System.out.println(SingleObject1.getInstance().toString()); System.out.println(singleObject2.toString()); System.out.println(SingleObject2.getInstance().toString()); System.out.println(singleObject3.toString()); System.out.println(SingleObject3.getInstance().toString()); }} 输出结果： SingleObject SingleObject1 SingleObject2 SingleObject3 singleton.SingleObject@1b6d3586 singleton.SingleObject@1b6d3586 singleton.SingleObject1@4554617c singleton.SingleObject1@4554617c singleton.SingleObject2@74a14482 singleton.SingleObject2@74a14482 singleton.SingleObject3@1540e19d singleton.SingleObject3@1540e19d饿汉式和懒汉式的区别： ​ 1、饿汉式是空间换时间，懒汉式是空间换时间。 ​ 2、在多线程访问的时候，懒汉式可能会创建多个对象，而饿汉式不会。","link":"/2020/06/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"title":"JAXBContext及其优化","text":"JAXBContext介绍JAXB的全称是Java Architecture for XML Binding，是一项可以通过XML产生Java对象，也可以通过Java对象产生XML的技术。JDK中关于JAXB部分有几个比较重要的接口或类，如： JAXBContext：它是程序的入口类，提供了XML/Java绑定的操作，包括marshal、unmarshal等。 Marshaller：它负责把Java对象序列化为对应的XML。 Unmarshaller：它负责把XML反序列化为对应的Java对象。 序列化与反序列化序列化12345678910111213141516//1、获取一个基于某个class的JAXBContext，即JAXB上下文JAXBContext jaxbContext = JAXBContext.newInstance(obj.getClass());//2、从上下文中获取Marshaller对象，用作将bean(转换)为xmlMarshaller marshaller = jaxbContext.createMarshaller();//3、设置一些序列化时需要的指定的配置//编码格式 （默认编码就是utf-8）marshaller.setProperty(Marshaller.JAXB_ENCODING, \"UTF-8\");//是否格式化生成的xml串,即按标签自动换行，否则就是一行输出marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);//是否省略xm头声明信息 默认不省略（false）marshaller.setProperty(Marshaller.JAXB_FRAGMENT, Boolean.FALSE);StringWriter writer = new StringWriter();//4、将对象进行序列化marshaller.marshal(obj, writer);String result = writer.toString();System.out.println(\"JavaBean转xml:\" + result); 1、 创建一个JAXB上下文对象。 2、 利用JAXB上下文对象创建对应的Marshaller对象。 3、 指定序列化时的配置参数，具体可以设置的参数和对应的参数的含义可以参考API文档。 4、 最后一步是将对应的对象序列化到一个Writer、OutputStream、File等输出对象中，具体可以参考Marshaller接口的API文档。 使用JAXB进行对象的序列化时对应的对象类型必须是javax.xml.bind.JAXBElement类型，或者是使用了javax.xml.bind.annotation.XmlRootElement注解标注的类型。 XmlRootElement用于标注在class上面，表示把一个class映射为一个XML Element对象。与之相配合使用的注解通常还有XmlElement和XmlAttribute。 XmlElement注解用于标注在class的属性上，用于把一个class的属性映射为一个XML Element对象。 XmlAttribute注解用于标注在class的属性上，用于把一个class的属性映射为其class对应的XML Element上的一个属性。默认情况下，当我们的一个属性没有使用XmlElement标注时也会被序列化为Xml元素的一个子元素，如果我们不希望Java对象中的某个属性被序列化则可以在对应的属性或对应的get方法上采用XMLTransient进行标注。 JavaBean实例类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class Person { private int id; private String name; private String gender; private String addres; private String area; public Person() { } public Person(String name, String gender, String addres, String area) { this.name = name; this.gender = gender; this.addres = addres; this.area = area; } public int getId() { return id; } @XmlElement public void setId(int id) { this.id = id; } public String getName() { return name; } @XmlElement public void setName(String name) { this.name = name; } public String getGender() { return gender; } @XmlElement public void setGender(String gender) { this.gender = gender; } public String getAddres() { return addres; } @XmlElement public void setAddres(String addres) { this.addres = addres; } public String getArea() { return area; } @XmlElement public void setArea(String area) { this.area = area; } @Override public String toString() { return \"Person{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", gender='\" + gender + '\\'' + \", addres='\" + addres + '\\'' + \", area='\" + area + '\\'' + '}'; } } 测试方法1234567891011121314151617181920212223242526272829303132333435public static void main(String[] args) throws JAXBException { Person person = new Person(); person.setId(1); person.setAddres(\"北京市朝阳区xxx\"); person.setGender(\"男\"); person.setName(\"CWF\"); person.setArea(\"北京市\"); //1、获取一个基于某个class的JAXBContext，即JAXB上下文 JAXBContext jaxbContext = JAXBContext.newInstance(person.getClass()); //2、从上下文中获取Marshaller对象，用作将bean(转换)为xml Marshaller marshaller = jaxbContext.createMarshaller(); //3、设置一些序列化时需要的指定的配置 //编码格式 （默认编码就是utf-8） marshaller.setProperty(Marshaller.JAXB_ENCODING, \"UTF-8\"); //是否格式化生成的xml串,即按标签自动换行，否则就是一行输出 marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE); //是否省略xm头声明信息 默认不省略（false） marshaller.setProperty(Marshaller.JAXB_FRAGMENT, Boolean.FALSE); StringWriter writer = new StringWriter(); //4、将对象进行序列化 marshaller.marshal(person, writer); String result = writer.toString(); System.out.println(\"JavaBean转xml:\" + result);}输出结果：JavaBean转xml:&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?&gt;&lt;person&gt; &lt;addres&gt;北京市朝阳区xxx&lt;/addres&gt; &lt;area&gt;北京市&lt;/area&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;id&gt;1&lt;/id&gt; &lt;name&gt;CWF&lt;/name&gt;&lt;/person&gt; 反序列化123456789String xmlSource = \"&lt;?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?&gt;&lt;person&gt;&lt;addres&gt;北京市朝阳区xxx&lt;/addres&gt;&lt;area&gt;北京市&lt;/area&gt;&lt;gender&gt;男&lt;/gender&gt;&lt;id&gt;1&lt;/id&gt;&lt;name&gt;CWF&lt;/name&gt;&lt;/person&gt;\";//1、创建一个指定class的JAXB上下文对象JAXBContext context = JAXBContext.newInstance(Person.class);//2、通过JAXBContext对象创建对应的Unmarshaller对象。Unmarshaller unmarshaller = context.createUnmarshaller();//3、调用Unmarshaller对象的unmarshal方法进行反序列化，接收的参数可以是一个InputStream、Reader、File等StringReader stringReader = new StringReader(xmlSource);Person person = (Person) unmarshaller.unmarshal(stringReader);System.out.println(person.toString()); Unmarshaller对象在提供了一系列的unmarshal重载方法，对应的参数类型可以是File、InputStream、Reader等，具体的可以查看对应的API文档。 JAXB工具类从jdk1.7开始，JAXB就对解组和编组的方法进行了更简单的封装，所以实际项目中除非自己要进行个性化设置，否则大可不用自己再创建JAXBContext实例，直接通过JAXB静态调用相应的工具方法就行了，于是上面的测试方法可以写的更简练些： 12345678910111213141516171819202122public static void main(String[] args) { Person person = new Person(\"CWF\",\"男\",\"北京市朝阳区xxx\",\"北京市\"); StringWriter w = new StringWriter(); JAXB.marshal(person, new StreamResult(w)); String parseResult = w.toString(); System.out.println(\"序列化：\"+ parseResult); StringReader reader = new StringReader(parseResult); Person person2 = JAXB.unmarshal(reader, Person.class); System.out.println(\"反序列化:\"+person2.toString());}输出结果：序列化：&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?&gt;&lt;person&gt; &lt;addres&gt;北京市朝阳区xxx&lt;/addres&gt; &lt;area&gt;北京市&lt;/area&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;id&gt;0&lt;/id&gt; &lt;name&gt;CWF&lt;/name&gt;&lt;/person&gt;反序列化:Person{id=0, name='CWF', gender='男', addres='北京市朝阳区xxx', area='北京市'} 注解@XmlRootElement作用和用法：类级别的注解，将类映射为xml全局元素，也就是根元素。就像spring配置文件中的beans。 常与 @XmlType，@XmlAccessorType，@XmlAccessorOrder连用。 属性：该注解含有name和namespace两个属性。 namespace属性用于指定生成的元素所属的命名空间。 name属性用于指定生成元素的名字，若不指定则默认使用类名小写作为元素名。 1234567891011121314@XmlRootElement(name = \"xingming\")public class Person { private int id; ... 生成的xml: &lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?&gt; &lt;xingming&gt; &lt;addres&gt;北京市朝阳区xxx&lt;/addres&gt; &lt;area&gt;北京市&lt;/area&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;id&gt;1&lt;/id&gt; &lt;name&gt;CWF&lt;/name&gt; &lt;/xingming&gt; @XmlElement作用和用法：字段，方法，参数级别的注解。该注解可以将被注解的字段(非静态)，或者被注解的get/set方法对应的字段映射为本地元素，也就是子元素。默认使用字段名或get/set方法去掉前缀剩下部分小写作为元素名(在字段名和get/set方法符合命名规范的情况下)。 常与 @XmlValue，@XmlJavaTypeAdapter，@XmlElementWrapper连用。 属性：属性常用的属性有有：name、nillable、required、namespace、defaultValue name属性可以指定生成元素的名字nillable属性可以指定元素的文本值是否可以为空，默认为false。required属性可以指定该元素是否必须出现，默认为falsenamespace属性可以指定该元素所属的命名空间defaultValue属性可以指定该元素默认的文本值 @XmlAttribute作用和用法：字段和方法级别的注解。该注解会将字段或get/set方法对应的字段映射成本类对应元素的属性，属性名默认使用字段名或get/set方法去掉前缀剩下部分首字母小写(在字段名和get/set方法符合命名规范的情况下)。 属性：该注解有name，required，namespace三个属性。用法和@XmlElement注解相同 @XmlTransient作用和用法：类，字段，方法级别的注解。可使JAXB在映射xml元素时忽略被注解的类，字段，get/set对应字段。需要注意的是该注解与所有其他JAXB注释相互排斥，也就是说与其他注释连用就会报错。 123456789101112@XmlTransientpublic void setAddres(String addres) { this.addres = addres;}生成xml:&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?&gt;&lt;person&gt; &lt;area&gt;华北地区&lt;/area&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;id&gt;1&lt;/id&gt; &lt;name&gt;CWF&lt;/name&gt;&lt;/person&gt; JAXB优化JAXBContext的实例需要通过JAXBContext.newInstance(..)方法产生，JAXBContext中定义了重载的5个newInstance(..)方法如下 12345public static JAXBContext newInstance( String contextPath )public static JAXBContext newInstance( String contextPath, ClassLoader classLoader )public static JAXBContext newInstance( String contextPath, ClassLoader classLoader, Map&lt;String,?&gt; properties )public static JAXBContext newInstance( Class... classesToBeBound )public static JAXBContext newInstance( Class[] classesToBeBound, Map&lt;String,?&gt; properties ) 上述5个方法的区别在于是基于package的还是基于class的。 contextPath用于指定需要绑定XML的Java类所在的包定义。 classLoader用于指定使用的类加载器，未指定时将使用当前线程上下文所绑定的类加载器。 properties用于指定JAXB实现者特定的属性;classesToBeBound用于直接指定需要绑定的Java类。 每次在创建JAXBContext实例时，JAXBContext内部都需要维护好Java类和XML之间的映射关系，这个操作是十分消耗性能的。但JAXBContext是线程安全的，可以共享。 测试代码: 123456789101112131415161718192021222324@Testpublic void test() throws Exception { String xmlResult = testServiceImpl.getResourceStr(); for (int j=0; j&lt;5; j++) { int times = 100000; long t1 = System.currentTimeMillis(); for (int i=0; i&lt;times; i++) { JAXBContext jaxbContext = JAXBContext.newInstance(TestRS.class); Marshaller marshaller = jaxbContext.createMarshaller(); marshaller.marshal(new TestRS(), new StringWriter()); } long t2 = System.currentTimeMillis(); System.out.println(\"不共用JAXBContext耗时：\" + (t2-t1) + \"ms\"); long t3 = System.currentTimeMillis(); JAXBContext jaxbContext = JAXBContext.newInstance(TestRS.class); for (int i=0; i&lt;times; i++) { Marshaller marshaller = jaxbContext.createMarshaller(); marshaller.marshal(new TestRS(), new StringWriter()); } long t4 = System.currentTimeMillis(); System.out.println(\"共用JAXBContext耗时：\" + (t4-t3) + \"ms\"); }} 循环测试5次，每次分别在共享JAXBContext和不共享JAXBContext的情况下进行五次marshal操作，由于这里我们不关心生成的XML，也避免输出到控制台或文件中的IO影响，这里每次都创建一个StringWriter，StringWriter是基于内存操作的。 执行结果:不共用JAXBContext耗时：17953ms 共用JAXBContext耗时：3548ms 不共用JAXBContext耗时：17406ms 共用JAXBContext耗时：3414ms 不共用JAXBContext耗时：19187ms 共用JAXBContext耗时：3703ms 不共用JAXBContext耗时：18819ms 共用JAXBContext耗时：3369ms 不共用JAXBContext耗时：17401ms 共用JAXBContext耗时：3728ms 从测试结果我们可以很明显的看到共享JAXBContext的情况下性能有很明显的提升。共享JAXB时如果我们的所有的应用场景需要使用到的Class比较少时我们可以简单的在创建JAXBContext对象时传递所有需哟使用到的Class，把它保存起来之后都可以一直这样在我们的应用中使用它了。但是如果Class的定义在进行XML转换为Java对象时有冲突就不能这么做了，比如你有一个Person1和Person2两个Person类，它们映射的XML节点都是person，那么在把XML节点person转换为Java对象时是转换为Person1还是Person2呢？有这种场景获取Class相对较多时建议创建一个JaxbUtil工具类，所有的JAXBContext对象都由该工具类产生，在该工具类内部实现JAXBContext的重用。 1234567891011121314public class JAXBContextUtil { private static Map&lt;List&lt;Class&lt;?&gt;&gt;, JAXBContext&gt; jaxbContextMap = new ConcurrentHashMap&lt;&gt;(); public static JAXBContext getJAXBContext(Class&lt;?&gt;classes) throws JAXBException { List&lt;Class&lt;?&gt;&gt; classList = new ArrayList&lt;&gt;(Arrays.asList(classes)); if (!jaxbContextMap.containsKey(classList)) { JAXBContext jaxbContext = JAXBContext.newInstance(classes); jaxbContextMap.put(classList, jaxbContext); return jaxbContext; } return jaxbContextMap.get(classList); }} 需要注意的是虽然JAXBContext是线程安全的，但是它由它产生的Marshaller和Unmarshaller对象是线程不安全的，切勿进行重用。","link":"/2020/03/06/JAXBContext%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"},{"title":"SpringBoot集成RabbitMQ","text":"Springboot 集成 RabbitMQRabbitMQ 是一个用 Erlang 语言开发的 AMQP 开源实现。AMQP（Advanced Message Queue Protocol），高级消息队列协议，是异步消息处理领域的一个公开标准，主要由 Cisco、RedHat 等联合制定。而 RabbitMQ 就是 AMQP 的一个开源实现，由 RabbitMQ Technologies Ltd 公司开发并提供商业支持。RabbitMQ 即一个消息队列，主要是用来实现应用程序的异步和解耦，同时也能起到消息缓冲，消息分发的作用。RabbitMQ 主要应用于大型系统中不同的应用或者子系统之间的通信，通过分隔数据的发送和接收来解耦应用。 RabbitMQ关键词 关键词 说明 Broker 消息队列服务器实体。 Exchange 消息交换机，它指定消息按什么规则，路由到哪个队列。 Queue 消息队列载体，每个消息都会被投入到一个或多个队列。 Binding 绑定，它的作用就是把exchange和queue按照路由规则绑定起来。 Routing Key 路由关键字，exchange根据这个关键字进行消息投递。 vhost 虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。 producer 消息生产者，就是投递消息的程序。 consumer 消息消费者，就是接受消息的程序。 channel 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。 RabbitMQ消息流程当生产者发布一条消息时，首先跟 RabbitMQ 建立连接（channel），通过该连接将想要发布的消息发送到交换器（exchange）上。交换器通过特定的路由规则（routing_key），将消息发送到某个队列（queue）。RabbitMQ 会监控该队列，一旦发现有消费者订阅了该队列，就将消息发送给消费者进行处理，然后将该消息从队列中删除。 1、客户端连接到消息队列服务器，打开一个channel。2、客户端声明一个exchange，并设置相关属性。3、客户端声明一个queue，并设置相关属性。4、客户端使用routing key，在exchange和queue之间建立好绑定关系。5、客户端投递消息到exchange。 交换机(Exchange)交换机的功能主要是接收消息并且转发到绑定的队列，交换机不存储消息，交换机有四种类型：Direct, topic, Headers and Fanout。 Direct：direct 类型的行为是”先匹配, 再投送”. 即在绑定时设定一个 routing_key, 消息的routing_key 匹配时, 才会被交换器投送到绑定的队列中去. Topic：按规则转发消息（最灵活） Headers：设置 header attribute 参数类型的交换机 Fanout：转发消息到所有绑定队列 Direct ExchangeDirect Exchange 是 RabbitMQ 默认的交换机模式,根据routing_key匹配队列。 Topic ExchangeTopic Exchange 转发消息主要是根据通配符。 在这种交换机下，队列和交换机的绑定会定义一种路由模式，那么，通配符就要在这种路由模式和路由键之间匹配后交换机才能转发消息。 路由键必须是一串字符，用句号（.） 隔开，比如说 agreements.us，或者 agreements.eu.stockholm 等。 路由模式必须包含一个 星号（），主要用于匹配路由键指定位置的一个单词，比如说，一个路由模式是这样子：agreements..b.，那么就只能匹配路由键是这样子的：第一个单词是 agreements，第四个单词是 b。 井号（#）就表示相当于一个或者多个单词，例如一个匹配模式是 agreements.eu.berlin.#，那么，以agreements.eu.berlin 开头的路由键都是可以的。 具体代码发送的时候还是一样，第一个参数表示交换机，第二个参数表示 routing key，第三个参数即消息。如下： rabbitTemplate.convertAndSend(&quot;testTopicExchange&quot;,&quot;key1.a.c.key2&quot;, &quot; this is RabbitMQ!&quot;);*表示一个词. #表示零个或多个词. Headers Exchangeheaders 也是根据规则匹配, 相较于 direct 和 topic 固定地使用 routing_key , headers 则是一个自定义匹配规则的类型。在队列与交换器绑定时, 会设定一组键值对规则, 消息中也包括一组键值对( headers 属性), 当这些键值对有一对, 或全部匹配时, 消息被投送到对应队列。 Fanout ExchangeFanout Exchange 消息广播的模式，不管路由键或者是路由模式，会把消息发给绑定给它的全部队列，如果配置了 routing_key 会被忽略。 1、pom文件增加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 2、配置文件增加mq配置12345#ma配置spring.rabbitmq.host=127.0.0.1spring.rabbitmq.port=5672spring.rabbitmq.username=guestspring.rabbitmq.password=guest 3、发送消息发送消息工具类,注入RabbitTemplate模版，只用RabbitTemplate发送消息。 12345678910111213141516171819202122@Componentpublic class SendMessageUtil { private static Logger logger = LoggerFactory.getLogger(SendMessageUtil.class); @Autowired private RabbitTemplate rabbitTemplate; private static RabbitTemplate myRabbitTemplate; private final static String DIR_EXCHANGE = \"test.direct\"; @PostConstruct public void init(){ myRabbitTemplate = rabbitTemplate; } public static &lt;T&gt; void sendMessage(String exchange, String routingKey, MQMessage&lt;T&gt; mqConstant){ logger.info(\"----开始发送消息：交换机【\"+exchange+\"】，routingKey【\" + routingKey + \"】，消息【\"+JSON.toJSONString(mqConstant)+\"】----------\"); myRabbitTemplate.convertAndSend(exchange, routingKey, mqConstant); logger.info(\"----结束发送消息----------\"); }} 发送消息测试 123456789101112131415161718192021222324@SpringBootTest(classes = {ServiceApplication.class})@RunWith(SpringRunner.class)public class RabbitMqListenerTest { @Autowired private RabbitTemplate rabbitTemplate; @Test public void reserveOrderStatusListener() throws InterruptedException { for (int i = 1; i &lt;= 10; i++) { Person person = new Person(); person.setUid(i); person.setEmail(\"abc\"+i+\"@test.com\"); person.setName(\"abc\"+i); MQMessage&lt;Person&gt; mqData = new MQMessage&lt;&gt;(); mqData.setMessage(\"推送消息\"+i); mqData.setMessageId(\"MID\"+RandomUtil.getInstance()); mqData.setData(person); SendMessageUtil.sendMessage(RabbitMQConstant.Exchage.DEFAULT_EXCHANGE,RabbitMQConstant.RoutingKey.TEST_QUEUE, mqData); } }} 5、消费信息配置SimpleRabbitListenerContainerFactory 1234567891011121314151617181920212223@Configurationpublic class RabbitMqConfig { /** * 消费者数量，默认10 */ public static final int DEFAULT_CONCURRENT = 10; /** * 每个消费者获取最大投递数量 默认50 */ public static final int DEFAULT_PREFETCH_COUNT = 50; @Bean(\"pointTaskContainerFactory\") public SimpleRabbitListenerContainerFactory pointTaskContainerFactory(SimpleRabbitListenerContainerFactoryConfigurer configurer, ConnectionFactory connectionFactory) { SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory(); factory.setPrefetchCount(DEFAULT_PREFETCH_COUNT); factory.setConcurrentConsumers(DEFAULT_CONCURRENT); configurer.configure(factory, connectionFactory); return factory; }} 监听队列 12345678910111213141516171819202122232425262728293031@Componentpublic class RabbitMqListener { private static Logger logger = LoggerFactory.getLogger(RabbitMqListener.class); /** * 可以直接通过注解声明交换器、绑定、队列 * @author ccwf * @date 2020/3/28 14:09 * @param mqData \b* @param channel \b* @param message * @return void */ @RabbitListener( bindings = @QueueBinding( exchange = @Exchange(value = RabbitMQConstant.Exchage.DEFAULT_EXCHANGE, type = ExchangeTypes.DIRECT, durable = \"ture\"), value = @Queue(value = RabbitMQConstant.Queue.TEST_QUEUE, durable = \"ture\"), key = RabbitMQConstant.RoutingKey.TEST_QUEUE ), //手动指明消费者的监听容器，默认Spring为自动生成一个SimpleMessageListenerContainer containerFactory = \"pointTaskContainerFactory\" ) public void testQueueListener(MQMessage&lt;Person&gt; mqData, Channel channel, Message message) throws IOException { logger.info(\"------队列【\" + RabbitMQConstant.Queue.TEST_QUEUE + \"】------消息【\" + mqData + \"】----------\"); System.out.println(\"消息data:\"+JSONObject.toJSONString(mqData.getData())); logger.info(\"channel:\",JSONObject.toJSONString(channel)); logger.info(\"message:\",JSONObject.toJSONString(message)); }} 消费结果： 12342020-03-28 14:06:20.530 [SimpleAsyncTaskExecutor-1] INFO com.cwf.demo.mq.consumer.RabbitMqListener - ------队列【test_queue】------消息【MqConstans{message='推送消息10', messageId='MIDcom.cwf.util.RandomUtil@298b64f7'}】----------消息data:{\"email\":\"abc10\",\"uid\":10}2020-03-28 14:06:20.546 [SimpleAsyncTaskExecutor-1] INFO com.cwf.demo.mq.consumer.RabbitMqListener - channel:2020-03-28 14:06:20.546 [SimpleAsyncTaskExecutor-1] INFO com.cwf.demo.mq.consumer.RabbitMqListener - message: ​","link":"/2020/02/27/SpringBoot%E9%9B%86%E6%88%90RabbitMQ/"},{"title":"使用redisson实现分布式锁","text":"Redisson概述Redisson是架设在Redis基础上的一个Java驻内存数据网格（In-Memory Data Grid）。充分的利用了Redis键值数据库提供的一系列优势，基于Java实用工具包中常用接口，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作 SpringBoot集成Redisson引入依赖12345&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.9.1&lt;/version&gt;&lt;/dependency&gt; 初始化连接//哨兵server配置 private SentinelServersConfig sentinelServersConfig; //主从server配置 private MasterSlaveServersConfig masterSlaveServersConfig; //单节点server配置 private SingleServerConfig singleServerConfig; //集群server配置 private ClusterServersConfig clusterServersConfig; //云托管模式配置 private ReplicatedServersConfig replicatedServersConfig;这里我们使用单节点及集群配置 applition-env.properties增加redis相关配置 123456789101112131415161718//单节点spring.redis.host=127.0.0.1spring.redis.port=6379spring.redis.password=spring.redis.pool.max-active=100spring.redis.pool.max-wait=-1spring.redis.pool.max-idle=500spring.redis.pool.min-idle=10spring.redis.timeout=60000//集群spring.redis.cluster.nodes=192.168.1.31:6379,192.168.1.32:6379,192.168.1.33:6379,192.168.1.34:6379,192.168.1.35:6379,192.168.1.36:6379spring.redis.cluster.timeout=2000spring.redis.password=spring.redis.pool.max-active=500spring.redis.pool.max-wait=-1spring.redis.pool.max-idle=500spring.redis.pool.min-idle=10spring.redis.timeout=60000 增加配置类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@Configuration@Slf4jpublic class RedissonConfig { @Bean(&quot;redissonClient&quot;) public RedissonClient redissonClient(RedisProperties redisProperties) { if (Objects.isNull(redisProperties)) { log.error(&quot;redisson-redis配置为空&quot;); return null; } RedisProperties.Cluster cluster = redisProperties.getCluster(); String rp = redisProperties.getPassword(); boolean clusterFlag = cluster != null ? true : false; if (clusterFlag) { log.info(&quot;redisson 集群模式：{}&quot;, JSONObject.toJSONString(cluster)); Config config = new Config(); List&lt;String&gt; nodes = cluster.getNodes(); List&lt;String&gt; redissonNodes = new ArrayList(nodes.size()); nodes.forEach(index -&gt; redissonNodes.add(index.startsWith(&quot;redis://&quot;) ? index : &quot;redis://&quot;.concat(index))); ClusterServersConfig clusterServersConfig = config.useClusterServers() //集群节点 .addNodeAddress(redissonNodes.toArray(new String[0])) //集群状态扫描间隔时间，单位是毫秒 .setScanInterval(1000) //读取数据超时 3000毫秒 .setIdleConnectionTimeout(3000) //连接超时 .setConnectTimeout(3000) //执行失败最大次数默认值：3 .setFailedAttempts(3) //（命令失败重试次数） 默认值：3 .setRetryAttempts(3) //命令重试发送时间间隔，单位：毫秒 默认值：1000 .setRetryInterval(1000) //主节点连接池大小 默认值：64 .setMasterConnectionPoolSize(64) //从节点连接池大小 默认值：64 .setSlaveConnectionPoolSize(64) //等待节点回复命令的时间。该时间从命令发送成功时开始计时 .setTimeout(redisProperties.getTimeout()); if (StringGwtripUtils.isNotEmpty(rp)) { clusterServersConfig.setPassword(rp); } return Redisson.create(config); } else { log.info(&quot;redisson 单机模式:{}&quot;, JSONObject.toJSONString(redisProperties)); Config config = new Config(); String node = redisProperties.getHost() + &quot;:&quot; + redisProperties.getPort(); node = node.startsWith(&quot;redis://&quot;) ? node : &quot;redis://&quot; + node; //spring.redis.pool.max-active=500 //spring.redis.pool.max-wait=-1 //spring.redis.pool.max-idle=500 //spring.redis.pool.min-idle=10 SingleServerConfig singleServerConfig = config.useSingleServer() .setAddress(node) //连接超时 .setConnectTimeout(3000) //连接池大小 .setConnectionPoolSize(64) //最小空闲连接数 .setConnectionMinimumIdleSize(redisProperties.getPool().getMinIdle()); if (StringGwtripUtils.isNotEmpty(rp)) { singleServerConfig.setPassword(rp); } return Redisson.create(config); } }} 使用Redisson实现分布式锁1234567891011121314public interface DistributedLocker { RLock lock(String lockKey); RLock lock(String lockKey, int timeout); RLock lock(String lockKey, TimeUnit unit, int timeout); boolean tryLock(String lockKey, TimeUnit unit, int waitTime, int leaseTime); void unlock(String lockKey); void unlock(RLock lock);} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Componentpublic class RedisDistributedLocker implements DistributedLocker { @Autowired private RedissonClient redissonClient; @Override public RLock lock(String lockKey) { RLock lock = redissonClient.getLock(lockKey); lock.lock(); return lock; } @Override public RLock lock(String lockKey, int timeout) { RLock lock = redissonClient.getLock(lockKey); lock.lock(timeout, TimeUnit.SECONDS); return lock; } @Override public RLock lock(String lockKey, TimeUnit unit, int timeout) { RLock lock = redissonClient.getLock(lockKey); lock.lock(timeout, unit); return lock; } @Override public boolean tryLock(String lockKey, TimeUnit unit, int waitTime, int leaseTime) { RLock lock = redissonClient.getLock(lockKey); try { return lock.tryLock(waitTime,unit); } catch (InterruptedException e) { return false; } } @Override public void unlock(String lockKey) { RLock lock = redissonClient.getLock(lockKey); lock.unlock(); } @Override public void unlock(RLock lock) { lock.unlock(); }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283@Componentpublic class RedisLockUtil { @Autowired private DistributedLocker locker; private static DistributedLocker distributedLocker; private RedisLockUtil() { } @PostConstruct private void init() { distributedLocker = locker; } /** * 加锁 * @param lockKey * @return */ public static RLock lock(String lockKey) { return distributedLocker.lock(lockKey); } /** * 释放锁 * @param lockKey */ public static void unlock(String lockKey) { distributedLocker.unlock(lockKey); } /** * 释放锁 * @param lock */ public static void unlock(RLock lock) { distributedLocker.unlock(lock); } /** * 带超时的锁 * @param lockKey * @param timeout 超时时间 单位：秒 */ public static RLock lock(String lockKey, int timeout) { return distributedLocker.lock(lockKey, timeout); } /** * 带超时的锁 * @param lockKey * @param unit 时间单位 * @param timeout 超时时间 */ public static RLock lock(String lockKey, int timeout, TimeUnit unit ) { return distributedLocker.lock(lockKey, unit, timeout); } /** * 尝试获取锁 * @param lockKey * @param waitTime 最多等待时间 * @param leaseTime 上锁后自动释放锁时间 * @return */ public static boolean tryLock(String lockKey, int waitTime, int leaseTime) { return distributedLocker.tryLock(lockKey, TimeUnit.SECONDS, waitTime, leaseTime); } /** * 尝试获取锁 * @param lockKey * @param unit 时间单位 * @param waitTime 最多等待时间 * @param leaseTime 上锁后自动释放锁时间 * @return */ public static boolean tryLock(String lockKey, TimeUnit unit, int waitTime, int leaseTime) { return distributedLocker.tryLock(lockKey, unit, waitTime, leaseTime); }} 测试123456789101112131415161718192021222324252627282930313233@Testpublic void testRedisLock(){ RedisUtil.set(&quot;test&quot;,null); boolean l1 = RedisLockUtil.tryLock(&quot;abc&quot;, TimeUnit.SECONDS, 5, 30); System.out.println(DateTimeConvert.getNowTime()+&quot;l&quot;); new Thread(()-&gt;{ boolean abc = RedisLockUtil.tryLock(&quot;abc&quot;, TimeUnit.SECONDS, 5, 30); System.out.println(DateTimeConvert.getNowTime()+&quot;l2&quot;); if (abc){ System.out.println(&quot;l2unlock&quot;); RedisLockUtil.unlock(&quot;abc&quot;); } }).start(); new Thread(()-&gt;{ boolean abc = RedisLockUtil.tryLock(&quot;abc&quot;, TimeUnit.SECONDS, 6, 30); System.out.println(DateTimeConvert.getNowTime()+&quot;l3&quot;); if (abc){ System.out.println(&quot;l3unlock&quot;); RedisLockUtil.unlock(&quot;abc&quot;); } }).start(); try { TimeUnit.SECONDS.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } if (l1){ System.out.println(&quot;l1unlock&quot;); RedisLockUtil.unlock(&quot;abc&quot;); }} 测试结果: 12342020-08-14 11:30:17l2020-08-14 11:30:22l22020-08-14 11:30:23l32020-08-14 11:30:27l1unlock 主线程l1获取锁，十秒后释放。l2,l3线程尝试五秒获取锁未获取到直接执行。","link":"/2020/08/14/%E4%BD%BF%E7%94%A8redisson%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"}],"tags":[{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Dubbo","slug":"Dubbo","link":"/tags/Dubbo/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"ide","slug":"ide","link":"/tags/ide/"},{"name":"RabbitMQ","slug":"RabbitMQ","link":"/tags/RabbitMQ/"},{"name":"MyBatis","slug":"MyBatis","link":"/tags/MyBatis/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"JAXB","slug":"JAXB","link":"/tags/JAXB/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"}],"categories":[{"name":"系统运维","slug":"系统运维","link":"/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"}]}